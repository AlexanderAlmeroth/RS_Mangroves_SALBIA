// L9 2023 
// RANDOM FOREST 
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
function applyScaleFactorsL8(image) {
  var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);
  var thermalBands = image.select('ST_B.*').multiply(0.00341802).add(149.0);
  return image.addBands(opticalBands, null, true)
              .addBands(thermalBands, null, true);
}
var visualizationL8 = {
  bands: ['SR_B4', 'SR_B3', 'SR_B2'],
  min: 0.0,
  max: 0.3,
};
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
var L9_2023 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')
  .filterBounds(MaskGambia)
  .filterDate('2023-11-01', '2023-12-31')
  .map(applyScaleFactorsL8);
//-------------------------------------------------------------------------------------------
//SELECT THE LEAST CLOUDY ONES AND BUILD A COMPOSITE WITH THEM
var selectLeastCloudy2023 = function(scene) {
  var sceneImages = L9_2023.filter(ee.Filter.eq('WRS_PATH', scene.get('WRS_PATH')))
                                     .filter(ee.Filter.eq('WRS_ROW', scene.get('WRS_ROW')));
  var leastCloudy = sceneImages.sort('CLOUD_COVER').first();
  return leastCloudy;
};
var scenes9 = L9_2023.distinct(['WRS_PATH', 'WRS_ROW']);
var leastCloudyPerScene2023 = scenes9.map(selectLeastCloudy2023);
//print ('leastCloudyPerScene 9 2023', leastCloudyPerScene2023);

var leastCloudyCollection2023 = ee.ImageCollection(leastCloudyPerScene2023);
var medianComposite2023 = leastCloudyCollection2023.median();
Map.addLayer(medianComposite2023.clip(MaskGambia), visualizationL8, 'L9 2023 Median Selected');
//-------------------------------------------------------------------------------------------
//NDVI 
var ndvi = medianComposite2023.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI');
var medianCompositeNDVI = medianComposite2023.addBands(ndvi);
Map.addLayer(medianCompositeNDVI.clip(MaskGambia), {bands: ['NDVI'], min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'Image with NDVI');

//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// POLYGON APPROACH 
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// 3750 points in total 
// 750 for validation (150 per class) and 3000 training (600 per class) (80%/20%)
// here we only take 600 points since we do have the 150 points from the validation sites 

// TRAINING DATA
var polygons1 = ee.FeatureCollection(WaterPoly);
var randomPoints11 = ee.FeatureCollection.randomPoints(polygons1, 600);
var Waterpoints = randomPoints11.map(function(point) {
  var polygon = polygons1.filterBounds(point.geometry()).first();
  var featureWithClass = point.set(polygon.toDictionary());
  return featureWithClass.set('Class', ee.Number(0)); 
});

var polygons2 = ee.FeatureCollection(DrylandPoly);
var randomPoints2 = ee.FeatureCollection.randomPoints(polygons2, 600);
var Drylandpoints = randomPoints2.map(function(point) {
  var polygon = polygons2.filterBounds(point.geometry()).first();
  var featureWithClass = point.set(polygon.toDictionary());
  return featureWithClass.set('Class', ee.Number(1)); 
});

var polygons3 = ee.FeatureCollection(MudflatPoly);
var randomPoints3 = ee.FeatureCollection.randomPoints(polygons3, 600);
var Mudflatpoints = randomPoints3.map(function(point) {
  var polygon = polygons3.filterBounds(point.geometry()).first();
  var featureWithClass = point.set(polygon.toDictionary());
  return featureWithClass.set('Class', ee.Number(2)); 
});

var polygons4 = ee.FeatureCollection(MangrovePoly);
var randomPoints4 = ee.FeatureCollection.randomPoints(polygons4, 600);
var Mangrovepoints = randomPoints4.map(function(point) {
  var polygon = polygons4.filterBounds(point.geometry()).first();
  var featureWithClass = point.set(polygon.toDictionary());
  return featureWithClass.set('Class', ee.Number(3)); 
});

var polygons5 = ee.FeatureCollection(WoodlandPoly);
var randomPoints5 = ee.FeatureCollection.randomPoints(polygons5, 600);
var Woodlandpoints = randomPoints5.map(function(point) {
  var polygon = polygons5.filterBounds(point.geometry()).first();
  var featureWithClass = point.set(polygon.toDictionary());
  return featureWithClass.set('Class', ee.Number(4)); 
});

/-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// IN CASE THERE IS A ERROR MESSAGE // 

// FeatureCollection (Error)Collection.geometry: Unable to perform this geometry operation. Please specify a non-zero error margin.
// SOLUTION: Export Asset in EE-Asset or as shape -> then import it into the script ->  .geometry -> DONE! 

// FIX BROKEN COLLECTIONS (Multiple Geometry types) // 
//var polygons = Dryland.map(function (f) {return ee.Feature(f).set('geometry_type', ee.Feature(f).geometry().type()); }).filter(ee.Filter.equals('geometry_type', 'Polygon'));
//var polygonsnew = ee.FeatureCollection(polygons); print(polygonsnew);
//Map.addLayer(Dryland, {color: 'green'},'old'); Map.addLayer(polygonsnew, {color: 'black'},'new');

// Convert the feature collections to a geometry object.
        //var fcWood = WoodlandPoly.geometry();
// Get the drawing tools.
        //var drawingTools = Map.drawingTools();
// Transfer the feature collection geometry to the client.
    //fcWood.evaluate(function(geomList) {
// Add the geometry as a layer of the drawing tools.
 //drawingTools.addLayer([geomList], 'fcWood', 'lime');
   //});

//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// RANDOM FOREST MODEL //
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
//--------------------TRAINING-------------------- 
var trainingPoly =  Waterpoints.merge(Drylandpoints).merge(Mudflatpoints).merge(Mangrovepoints).merge(Woodlandpoints);
print(trainingPoly, 'Training set Polygons');

var bands = ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6','SR_B7','NDVI'];
var input = medianCompositeNDVI.select(bands);
var label = 'Class';

var trainImagePoly = input.sampleRegions({
  collection: trainingPoly,
  properties: [label],
  scale: 30
});

var trainSetPoly =  trainImagePoly; print('trainSetPoly',trainSetPoly);

// Classification Model
var classifierPoly = ee.Classifier.smileRandomForest(100)                                  
                  .train({
                    features: trainSetPoly,
                    classProperty: label,
                    inputProperties: bands
                  });                  
print('Results of trained classifier', classifierPoly.explain());     
//Classify the image
var classifiedPoly = input.select(bands).classify(classifierPoly);

var landcoverPalette = ['blue','yellow','brown','green','lime'];
Map.addLayer(classifiedPoly.clip(MaskGambia), {palette: landcoverPalette, min:0, max:4}, 'Classification Polygons');
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
//--------------------VALIDATION--------------------
// CONVERT THEM TO EDITABLE POLYGONS // 
// Convert the feature collections to a geometry object.  
var ValWater = Val_Wat.geometry(); //Water
var ValDryland = Val_Dry.geometry(); //Dryland
var ValMudflat = Val_Mud.geometry(); //Mudflat
var ValMangrove = Val_Man.geometry(); //Mangrove
var ValWoodland = Val_Wood.geometry(); //Woodland

// ------- Get the drawing tools.
// ------- Transfer the feature collection geometry to the client.
// ------- Add the geometry as a layer of the drawing tools.
 var drawingTools = Map.drawingTools();
 ValWater.evaluate(function(geomList) {
 drawingTools.addLayer([geomList], 'ValWater', 'blue');
 });

 ValDryland.evaluate(function(geomList) {
 drawingTools.addLayer([geomList], 'ValDryland', 'yellow');
 });

 ValMudflat.evaluate(function(geomList) {
 drawingTools.addLayer([geomList], 'ValMudflat', 'brown');
 });

 ValMangrove.evaluate(function(geomList) {
 drawingTools.addLayer([geomList], 'ValMangrove', 'green');
 });

 ValWoodland.evaluate(function(geomList) {
 drawingTools.addLayer([geomList], 'ValWoodland', 'green');
 });

//-----------------------------------------------------------------
var polygons1test = ee.FeatureCollection(ValWater);
var randomPoints1test = ee.FeatureCollection.randomPoints(polygons1test, 150);
var Waterpointstest = randomPoints1test.map(function(point) {
  var polygontest = polygons1test.filterBounds(point.geometry()).first();
  var featureWithClasstest = point.set(polygontest.toDictionary());
  return featureWithClasstest.set('Class', ee.Number(0)); 
});

var polygons2test = ee.FeatureCollection(ValDryland);
var randomPoints2test = ee.FeatureCollection.randomPoints(polygons2test, 150);
var Drylandpointstest = randomPoints2test.map(function(point) {
  var polygontest = polygons2test.filterBounds(point.geometry()).first();
  var featureWithClasstest = point.set(polygontest.toDictionary());
  return featureWithClasstest.set('Class', ee.Number(1)); 
});

var polygons3test = ee.FeatureCollection(ValMudflat);
var randomPoints3test = ee.FeatureCollection.randomPoints(polygons3test, 150);
var Mudflatpointstest = randomPoints3test.map(function(point) {
  var polygontest = polygons3test.filterBounds(point.geometry()).first();
  var featureWithClasstest = point.set(polygontest.toDictionary());
  return featureWithClasstest.set('Class', ee.Number(2)); 
});

var polygons4test = ee.FeatureCollection(ValMangrove);
var randomPoints4test = ee.FeatureCollection.randomPoints(polygons4test, 150);
var Mangrovepointstest = randomPoints4test.map(function(point) {
  var polygontest = polygons4test.filterBounds(point.geometry()).first();
  var featureWithClasstest = point.set(polygontest.toDictionary());
  return featureWithClasstest.set('Class', ee.Number(3)); 
});

var polygons5test = ee.FeatureCollection(ValWoodland);
var randomPoints5test = ee.FeatureCollection.randomPoints(polygons5test, 150);
var Woodlandpointstest = randomPoints5test.map(function(point) {
  var polygontest = polygons5test.filterBounds(point.geometry()).first();
  var featureWithClasstest = point.set(polygontest.toDictionary());
  return featureWithClasstest.set('Class', ee.Number(4)); 
});

var testingPoly =  Waterpointstest.merge(Drylandpointstest).merge(Mudflatpointstest).merge(Mangrovepointstest).merge(Woodlandpointstest);
print('Test Set Points',testingPoly);
var ValImagePoly = input.sampleRegions({
  collection: testingPoly,                                        
  properties: [label],
  scale: 30
});
var testSetPoly = ValImagePoly; print('Test Set',testSetPoly);
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// ADDING POINTS TO THE MAP
// TRAINING POINTS 
Map.addLayer(Waterpoints, {color:'#0000FF'}, 'Waterpoints');
Map.addLayer(Drylandpoints, {color:'#F0E68C'}, 'Drylandpoints');
Map.addLayer(Mudflatpoints, {color:'#A52A2A'}, 'Mudflatpoints');
Map.addLayer(Mangrovepoints, {color:'#00FF00'}, 'Mangrovepoints');
Map.addLayer(Woodlandpoints, {color:'#008000'}, 'Woodlandpoints');

// VALIDATION POINTS  
Map.addLayer(Waterpointstest, {color:'#0000FF'}, 'Waterpointstest');
Map.addLayer(Drylandpointstest, {color:'#F0E68C'}, 'Drylandpointstest');
Map.addLayer(Mudflatpointstest, {color:'#A52A2A'}, 'Mudflatpointstest');
Map.addLayer(Mangrovepointstest, {color:'#00FF00'}, 'Mangrovepointstest');
Map.addLayer(Woodlandpointstest, {color:'#008000'}, 'Woodlandpointstest');
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
//ACCURACY ASSESSMENT 
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
//TRAINING DATASET//
  var train_accuracy = classifierPoly.confusionMatrix(); print('Confusion Matrix', train_accuracy);
  var OA_training = train_accuracy.accuracy(); print('OA_training',OA_training);
  var Kappa_training = train_accuracy.kappa(); print('Kappa_training',Kappa_training);
  var PA_training = train_accuracy.producersAccuracy(); print('PA_training',PA_training);
  var CA_training = train_accuracy.consumersAccuracy(); print('CA_training',CA_training);

//VALIDATION DATASET// 
  var validated = testSetPoly.classify(classifierPoly);print(validated,'Validated');
  var test_accuracy = validated.errorMatrix('Class', 'classification'); print('Error Matrix',test_accuracy);
  var OA_validation = test_accuracy.accuracy();           print('OA_validation',OA_validation);
  var Kappa_validation = test_accuracy.kappa();           print('Kappa_validation',Kappa_validation);
  var PA_validation = test_accuracy.producersAccuracy();  print('PA_validation',PA_validation);
  var CA_validation = test_accuracy.consumersAccuracy();  print('CA_validation',CA_validation);

//-------------------------------------------------------------------------------------------
// FEATURE IMPORTANCE
var importance = ee.Dictionary(
  classifierPoly.explain().get('importance')
)
var totalImportance = importance.values().reduce(ee.Reducer.sum())
var importancePercentage = importance.map(function (band, importance) {
  return ee.Number(importance).divide(totalImportance).multiply(100)
})

print('importance', importance)
print('totalImportance', totalImportance)
print('importancePercentage', importancePercentage)

//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------                                                                     
// EXPORT
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------                                                                     
//  ---------------------  Exporting Training/Validation Sites  ---------------------  // 
// As Asset // 
var featuresWat = ee.FeatureCollection(WaterPoly);
Export.table.toAsset({
  collection: featuresWat,
  description:'2023WaterPoly',
  assetId: '2023WaterPoly',
});

var featuresDry = ee.FeatureCollection(DrylandPoly);
Export.table.toAsset({
  collection: featuresDry,
  description:'2023DrylandPoly',
  assetId: '2023DrylandPoly',
});

var featuresMud = ee.FeatureCollection(MudflatPoly);
Export.table.toAsset({
  collection: featuresMud,
  description:'2023MudflatPoly',
  assetId: '2023MudflatPoly',
});

var featuresMan = ee.FeatureCollection(MangrovePoly);
Export.table.toAsset({
  collection: featuresMan,
  description:'2023MangrovePoly',
  assetId: '2023MangrovePoly',
});

var featuresWod = ee.FeatureCollection(fcWoodland);
Export.table.toAsset({
  collection: featuresWod,
  description:'2023WoodlandPoly',
  assetId: '2023WoodlandPoly',
});


// As Shape // 
var fcMerged = MudflatPoly.merge(MangrovePoly).merge(DrylandPoly).merge(WaterPoly).merge(fcWoodland);
Export.table.toDrive({
  collection: testSetPoly,
  description:'Validation Points',
});

Export.table.toDrive({
  collection: trainSetPoly,
  description:'Training Points',
});

Export.table.toDrive({
  collection: MudflatPoly,
  description:'2023MudflatPoly',
});

Export.table.toDrive({
  collection: DrylandPoly,
  description:'2023DrylandPoly',
});

Export.table.toDrive({
  collection: WaterPoly,
  description:'2023WaterPoly',
});

Export.table.toDrive({
  collection: MangrovePoly,
  description:'2023MangrovePoly',
});

Export.table.toDrive({
collection: fcWoodland,
  description:'2023WoodlandPoly',
});

//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// EXPORT 
//-------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------
// CONVERT THE Crop-Boxes
// -> The file size of the TIFS is too large to be exported as one, that's why we cut them in half here and export them as "Cropped_1" and "Cropped_2". Afterwards they can be merged in another software.           

var Crop1 = Crop1.geometry(); 
var Crop2 = Crop2.geometry(); 

//EXPORT CLASSIFIED IMAGE                                                            
var classified_2023_Cropped_1 = classifiedPoly.clip(Crop1).clip(MaskGambia);
var classified_2023_Cropped_2 = classifiedPoly.clip(Crop2).clip(MaskGambia);
                                                                              
Export.image.toDrive({
   image: classified_2023_Cropped_1,
   description: 'classified_2023_Cropped_1_fin',
    folder: 'GEE_Export',
    fileNamePrefix: 'classified_2023_Cropped_1_fin',
    scale: 30,
    maxPixels: 1e13,
    region: Crop1,
    }); 
Export.image.toDrive({
    image: classified_2023_Cropped_2,
    description: 'classified_2023_Cropped_2_fin',
    folder: 'GEE_Export',
    fileNamePrefix: 'classified_2023_Cropped_2_fin',
    scale: 30,
    maxPixels: 1e13,
    region: Crop2,
    });     
    
//EXPORT COMPOSITE IMAGE
var Composite_2023_Cropped_1 = medianCompositeNDVI.clip(Crop1).clip(MaskGambia);
var Composite_2023_Cropped_2 = medianCompositeNDVI.clip(Crop2).clip(MaskGambia);

Export.image.toDrive({
    image: Composite_2023_Cropped_1.visualize(visualizationL8),
    description: 'Composite_2023_Cropped_1',
    folder: 'GEE_Export',
    fileNamePrefix: 'Composite_2023_Cropped_1',
    scale: 30,
    maxPixels: 1e13,
    region: Crop1,
    }); 
    
    
Export.image.toDrive({
    image: Composite_2023_Cropped_2.visualize(visualizationL8),
    description: 'Composite_2023_Cropped_2',
    folder: 'GEE_Export',
    fileNamePrefix: 'Composite_2023_Cropped_2',
    scale: 30,
    maxPixels: 1e13,
    region: Crop2,
    }); 


